%----------------------------------------------------------------------------------------
%	PACKAGES AND DOCUMENT CONFIGURATIONS
%----------------------------------------------------------------------------------------

\documentclass{article}
\usepackage{graphicx} % Required for the inclusion of images
\usepackage{subfigure} % Required for the inclusion of images
\usepackage{natbib} % Required to change bibliography style to APA
\usepackage{amsmath} % Required for some math elements 
\usepackage{listings}
\usepackage{graphicx} %插入图片的宏包
\usepackage{float} %设置图片浮动位置的宏包
\usepackage{subfigure} %插入多图时用子图显示的宏包
\usepackage{times} % Uncomment to use the Times New Roman font                               
%----------------------------------------------------------------------------------------
%	DOCUMENT INFORMATION
%----------------------------------------------------------------------------------------

\title{\textbf{Project 1: Optimizing the Performance of a Pipelined Processor}} % Title

\author{000, 赵梓淇, bugenzhao@sjtu.edu.cn \\
        001, 赵一民, doctormin@sjtu.edu.cn \\ } % Author name and email

\date{\today} % Date for the report

\begin{document}

\maketitle % Insert the title, author and date

\section{Introduction}
\textbf{Part A}
\\
In part A, we write three simple assembly programs to mimic three functions in example.c. 
Based on ensuring correctness，we especially focus on the functional equivalence with the example C functions. 
By selecting and placing labels in the assembly code appropriately, the code is also very readable.\\
\textbf{Part B}
\\
In part B, we modify the HCL file of the SEQ to add a new instruction --- iaddl. 
The following is the roadmap to finish this part:
\begin{itemize}
        \item Clarify the computation process of iadd and write it down at the beginning in seq-full.hcl.
        \item Add any dependence relations of iaddl to all boosigs.
        \item Design the datapath for iaddl (generate control signals for src and dst)
\end{itemize}
\textbf{Part C}
\\
We achieve full scores in the benchmark testing \textbf{in just 2 hours}, 
but we \textbf{spent 2 more days} researching all the potential methods to optimize the performance even further. 
The following is our roadmap:
\begin{itemize}
        \item Change the order of the instruction sequence to avoid data hazard and structure hazards, which leaves $CPI = 12.96$.
        \item Beyond the changes on instructions order, we use loop unrolling to reduce the number of conditional check and registers updating, which leaves $CPI = 9.83$
        \item Use a binary search tree to find the precise remaining number of loops after several rounds of unrolling to achieve complete unrolling, which leaves $CPI = 8.95$
        \item Modify the HCL file to achieve 100\% accuracy in branch prediction for certain code pattern, which brings $CPI$ down to $7.78$.
\end{itemize}
\textbf{Contribution}
\\
\textbf{Ziqi Zhao} : Part A (coding) \& Part B (coding) \& Part C (coding \& designing) \\
\textbf{Yimin Zhao} : Part A (reviewing) \& Part B (reviewing) \& Part C (designing) \& project report

\section{Experiments}
\subsection{Part A}
\subsubsection{Analysis}
In this part, we are asked to implement and simulate three y86 programs. 
From a macro point of view，this part is relatively easy. 
But there are plenty of optimizations worth exploring in terms of code readability and elegance.\\
\textbf{Difficult Point} 
\begin{itemize}
        \item Always pull the correct element from the stack.
        \item Be careful to protect the callee-save register.
        \item Implement function recursion smartly.
\end{itemize}
\textbf{Core Techniques}
\begin{itemize}
        \item Mimicking C functions, division of functional areas with enough and clear label.
        \item Get the fastest completion speed by coding line by line refering to C language functions
        \item Always draw a picture of the stack to ensure the correctness of fetching a variable.
\end{itemize}

\subsubsection{Code}
\begin{center}
        \textbf{sum.ys}
\end{center}
\begin{lstlisting}
# 518030910211 ZiqiZhao
# 518030910188 YiminZhao

# Set up stack
        .pos    0
        irmovl  stack,  %esp
        rrmovl  %esp,   %ebp
        pushl   %edx            # save %edx
        irmovl  ele1,   %eax
        pushl   %eax
        call    sum_list
        popl    %edx            # flatten the stack for ele1
        popl    %edx            # restore %edx
        halt

# Sample linked list 
.align 4
ele1:
        .long   0x00a
        .long   ele2
ele2:
        .long   0x0b0
        .long   ele3
ele3:
        .long   0xc00
        .long   0

# sum_list func
sum_list:
        pushl   %ebp            # enter
        pushl   %ecx            # save %ecx
        rrmovl  %esp,   %ebp
        xorl    %eax,   %eax    # clear %eax
        mrmovl  12(%ebp),%edx   # get ls
        jmp     test
loop:
        mrmovl  (%edx), %ecx
        addl    %ecx,   %eax
        mrmovl  4(%edx),%edx
test:
        andl    %edx,   %edx
        jne     loop            # %edx != 0
return:
        rrmovl  %ebp,   %esp    # leave
        popl    %ecx
        popl    %ebp
        ret

# Stack 
        .pos    0x400
stack:
\end{lstlisting}
\pagebreak
\begin{center}
        \textbf{rsum.ys}
\end{center}
\begin{lstlisting}
# 518030910211 ZiqiZhao
# 518030910188 YiminZhao

# Set up stack
    .pos    0
    irmovl  stack, %esp
    rrmovl  %esp, %ebp
    pushl   %edx
    irmovl  ele1, %eax
    pushl   %eax
    call    rsum_list
    popl    %edx           # eat ele1
    popl    %edx           # restore %edx
    halt

# Sample linked list 
.align 4
ele1:
    .long   0x00a
    .long   ele2
ele2:
    .long   0x0b0
    .long   ele3
ele3:
    .long   0xc00
    .long   0

# rsum_list func
rsum_list:
    pushl   %ebp            # enter
    rrmovl  %esp, %ebp
    xorl    %eax, %eax
    mrmovl  8(%ebp), %edx   # get ls
    andl    %edx, %edx
    je      return          # ls == NULL
do:
    pushl   %ebx            # save %ebx
    mrmovl  (%edx), %ebx    # mov ls->val to %ebx
    mrmovl  4(%edx), %eax
    pushl   %eax            # push ls->next
    call    rsum_list
    addl    %ebx, %eax      # ret = val + ret
    popl    %edx            # eat para
    popl    %ebx            # restore %ebx
return:
    rrmovl  %ebp, %esp      # leave
    popl    %ebp
    ret


# Stack 
    .pos    0x400
stack:
\end{lstlisting}
\begin{center}
        \textbf{copy.ys}
\end{center}
\begin{lstlisting}
# 518030910211 ZiqiZhao
# 518030910188 Yimin Zhao

# Set up stack
    .pos    0
    irmovl  stack, %esp
    rrmovl  %esp, %ebp
    irmovl  $3, %eax
    pushl   %eax
    irmovl  src, %eax
    pushl   %eax
    irmovl  dest, %eax
    pushl   %eax
    call    copy_block
    halt
.align 4
# Source block
src:
    .long 0x00a
    .long 0x0b0
    .long 0xc00

# Destination block
dest:
    .long 0x111
    .long 0x222
    .long 0x333

copy_block:
    pushl   %ebp
    rrmovl  %esp, %ebp
    pushl   %ecx
    pushl   %edx
    pushl   %edi
    irmovl  $0, %eax         # %eax = result = 0
    mrmovl  16(%ebp), %ecx   # %ecx = len
    mrmovl  12(%ebp), %edx   # %edx = src
    mrmovl  8(%ebp), %edi    # %edi = dest
    jmp     while_loop

while_loop:
    andl    %ecx, %ecx       # check if %ecx == 0?
    jle     return           # if so, jump to "return"
    mrmovl  (%edx), %esi     # %esi = val = *src
    irmovl  $4, %ebx         # %ebx = 4
    addl    %ebx, %edx       # src++
    rmmovl  %esi, (%edi)     # *dest = val
    addl    %ebx, %edi       # dest++
    xorl    %esi, %eax
    irmovl  $-1, %ebx
    addl    %ebx, %ecx       # len--
    jmp     while_loop

return:
    popl    %edi
    popl    %edx
    popl    %ecx
    rrmovl  %ebp, %esp
    popl    %ebp
    ret
# Stack 
    .pos    0x400
stack:
\end{lstlisting}
\pagebreak
\subsubsection{Evaluation}
\textbf{sum.ys}\\

\begin{figure}[H] %H为当前位置，!htb为忽略美学标准，htbp为浮动图形
        \centering %图片居中
        \includegraphics[width=0.7\textwidth]{partA-sum.jpg} %插入图片，[]中设置图片大小，{}中是图片文件名
        \caption{partA-sum.ys} %最终文档中希望显示的图片标题
        \label{Fig.partA-sum} %用于文内引用的标签
\end{figure}
\begin{itemize}
        \item The \%eax register has the correct value which is the return value of the function---$0xcba$.
        \item The memory is not corrupted since all the modifications locate at the stack whose starting addresss is set to be $0x400$.
\end{itemize}
\textbf{rsum.ys}\\

\begin{figure}[H] %H为当前位置，!htb为忽略美学标准，htbp为浮动图形
        \centering %图片居中
        \includegraphics[width=0.7\textwidth]{partA-rsum.jpg} %插入图片，[]中设置图片大小，{}中是图片文件名
        \caption{partA-rsum.ys} %最终文档中希望显示的图片标题
        \label{Fig.partA-rsum} %用于文内引用的标签
\end{figure}

\begin{itemize}
        \item The \%eax register has the correct value which is the return value of the function---$0xcba$.
        \item The memory is not corrupted since all the modifications locate at the stack whose starting addresss is set to be $0x400$.
\end{itemize}

\textbf{copy.ys}\\

\begin{figure}[H] %H为当前位置，!htb为忽略美学标准，htbp为浮动图形
        \centering %图片居中
        \includegraphics[width=0.7\textwidth]{partA-copy.jpg} %插入图片，[]中设置图片大小，{}中是图片文件名
        \caption{partA-copy.ys} %最终文档中希望显示的图片标题
        \label{Fig.partA-copy} %用于文内引用的标签
\end{figure}

\begin{itemize}
        \item The \%eax register has the correct value which is the return value of the function---$0xcba$.
        \item Values are written into the memory correctly as shown in the first three rows in the "Changes to memory" part in Figure 3
        \item The memory is not corrupted since all the modifications other than 3 source values locate at the stack whose starting addresss is set to be $0x400$.
\end{itemize}

\subsection{Part B}

\subsubsection{Analysis}
In part B, we are asked to extend the SEQ processor to support instruction "iaddl" by modifying SEQ-full.hcl.
Once we understand the processing logic and HCL syntax of the y86 seq processor, the problem becomes very simple.
We can do it in five minutes because all we need to do is change the followings in the HCL
\begin{itemize}
        \item Add "IIADDL" in the choices region of (bool) instr\_valid since iaddl is a valid instruction.
        \item Add "IIADDL" in the choices region of (bool) need\_regid since iaddl operation involves one register.
        \item Add "IIADDL" in the choices region of (bool) need\_valC since iaddl operation involves one constend(represented by valC in the circult of y86 SEQ).
        \item Add "IIADDL" in the choices region of (bool) set\_cc since iaddl operation involves ALU operation which will set flags.
        \item When icode is IIADDL, alufun will be ALUADD since the operation is "adding" the constand to rB.
        \item When icode is IIADDL, srcB is from rB since the second operand of iaddl is a register.
        \item When icode is IIADDL, dstE (where the result from ALU is passed towards) is rB since "iaddl constant, rB" means rB += constant (rB is updated). 
        \item When icode is IIADDL, aluA (the first op) is valC (the constant in the instruction) since "iaddl constant, rB" means the first op is the constant (valC).
        \item When icode is IIADDL, aluB (the second op) is valB (the value of the second register that is read) for the same reason above.
\end{itemize}
[In this part, you should give an overall analysis for the task, like difficult point, core technique and so on.]

\subsubsection{Code}
\begin{center}
        \textbf{Modifications in SEQ-full.hcl}
\end{center}
\begin{lstlisting}
--------------------------------------------------------------------
bool instr_valid = icode in 
{ INOP, IHALT, IRRMOVL, IIRMOVL, IRMMOVL, IMRMOVL,
       IOPL, IJXX, ICALL, IRET, IPUSHL, IPOPL, IIADDL };
--------------------------------------------------------------------
# Does fetched instruction require a regid byte?
bool need_regids =
        icode in { IRRMOVL, IOPL, IPUSHL, IPOPL, 
                IIRMOVL, IRMMOVL, IMRMOVL, IIADDL };
--------------------------------------------------------------------
# Does fetched instruction require a constant word?
bool need_valC =
        icode in { IIRMOVL, IRMMOVL, IMRMOVL, IJXX, ICALL, IIADDL };
--------------------------------------------------------------------
## What register should be used as the B source?
int srcB = [
        icode in { IOPL, IRMMOVL, IMRMOVL, IIADDL  } : rB;
        icode in { IPUSHL, IPOPL, ICALL, IRET } : RESP;
        1 : RNONE;  # Don't need register
];
--------------------------------------------------------------------
## What register should be used as the E destination?
int dstE = [
        icode in { IRRMOVL } && Cnd : rB;
        icode in { IIRMOVL, IOPL, IIADDL } : rB;
        icode in { IPUSHL, IPOPL, ICALL, IRET } : RESP;
        1 : RNONE;  # Don't write any register
];
--------------------------------------------------------------------
## Select input A to ALU
int aluA = [
        icode in { IRRMOVL, IOPL } : valA;
        icode in { IIRMOVL, IRMMOVL, IMRMOVL, IIADDL } : valC;
        icode in { ICALL, IPUSHL } : -4;
        icode in { IRET, IPOPL } : 4;
        # Other instructions don't need ALU
];
--------------------------------------------------------------------
## Select input B to ALU
int aluB = [
        icode in { IRMMOVL, IMRMOVL, IOPL, ICALL, 
                IPUSHL, IRET, IPOPL, IIADDL } : valB;
        icode in { IRRMOVL, IIRMOVL } : 0;
        # Other instructions don't need ALU
];
--------------------------------------------------------------------
## Set the ALU function
int alufun = [
        icode == IOPL : ifun;
        icode == IIADDL : ALUADD;
        1 : ALUADD;
];
--------------------------------------------------------------------
## Should the condition codes be updated?
bool set_cc = icode in { IOPL, IIADDL };
--------------------------------------------------------------------
\end{lstlisting}
\subsubsection{Evaluation}
\begin{figure}[H] %H为当前位置，!htb为忽略美学标准，htbp为浮动图形
        \centering %图片居中
        \includegraphics[width=1.0\textwidth]{partB-benchmark.jpg} %插入图片，[]中设置图片大小，{}中是图片文件名
        \caption{part B benchmark test} %最终文档中希望显示的图片标题
        \label{Fig.partB-benchmark} %用于文内引用的标签
\end{figure}
\begin{figure}[H] %H为当前位置，!htb为忽略美学标准，htbp为浮动图形
        \centering %图片居中
        \includegraphics[width=0.6\textwidth]{partB-regression-test.jpg} %插入图片，[]中设置图片大小，{}中是图片文件名
        \caption{part B regression test} %最终文档中希望显示的图片标题
        \label{Fig.partB-regression} %用于文内引用的标签
\end{figure}
\begin{figure}[H] %H为当前位置，!htb为忽略美学标准，htbp为浮动图形
        \centering %图片居中
        \includegraphics[width=0.6\textwidth]{partB-test-iaddl.jpg} %插入图片，[]中设置图片大小，{}中是图片文件名
        \caption{part B iaddl test} %最终文档中希望显示的图片标题
        \label{Fig.partB-iaddl} %用于文内引用的标签
\end{figure}
\subsection{Part C}

\subsubsection{Analysis}

[In this part, you should give an overall analysis for the task, like difficult point, core technique and so on.]

\subsubsection{Code}

[In this part, you should place your code and make it readable in Microsoft Word, please. Writing necessary comments for codes is a good habit.]

\subsubsection{Evaluation}

[In this part, you should place the figures of experiments for your codes, prove the correctness and validate the performance with your own words for each figure’s explanation.]

\section{Conclusion}

\subsection{Problems}

[In this part you can list the obstacles you met during the project, and better add how you overcome them if you have made it.]

\subsection{Achievements}

[In this part you can list the strength of your project solution, like the performance improvement, coding readability, partner cooperation and so on. You can also write what you have learned if you like.]



%----------------------------------------------------------------------------------------


\end{document}